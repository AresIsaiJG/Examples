/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include "LED.hpp"

TaskHandle_t PushTaskHandle = nullptr, LedTaskHandle = nullptr;

extern "C" void EXTI15_10_IRQHandler() {
    DRIVER_GPIO::PUSH_BOTTOM::PUSH_ClearInterrupt();

    vTaskNotifyGiveFromISR(PushTaskHandle, nullptr); // Notifica la tarea diferida y se ejecuta cuando pueda

}

extern "C" void EXTI9_5_IRQHandler() {
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    DRIVER_GPIO::LED::LED_ClearInterrupt();

    vTaskNotifyGiveFromISR(LedTaskHandle, &xHigherPriorityTaskWoken);

    portYIELD_FROM_ISR(xHigherPriorityTaskWoken); // Saliendo se habilita la tarea

}

static void TaskISR_LED(void *param)
{
	while (1)
	{
        ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		DRIVER_GPIO::GPIOB7_Conf.ptrGpioISR();
	}
}

static void TaskISR_PUSH(void *param)
{

	while (1)
	{
        ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		DRIVER_GPIO::GPIOC13_Conf.ptrGpioISR();
	}

}

int main(void)
{

	DRIVER_GPIO::GPIOC13_Conf.ptrGpioISR = DRIVER_GPIO::PUSH_BOTTOM::PUSH_ISR;
	DRIVER_GPIO::GPIOB7_Conf.ptrGpioISR = DRIVER_GPIO::LED::LED_ISR;

	DRIVER_GPIO::LED::LED_ClockPeriph();
	DRIVER_GPIO::PUSH_BOTTOM::PUSH_ClockPeriph();

	DRIVER_GPIO::LED::LED_Config();
	DRIVER_GPIO::LED::LED_InterruptConfig();

	DRIVER_GPIO::PUSH_BOTTOM::PUSH_Config();
	DRIVER_GPIO::PUSH_BOTTOM::PUSH_InterruptConfig();

	xTaskCreate(TaskISR_PUSH, "TaskPush", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 2, &PushTaskHandle);
	xTaskCreate(TaskISR_LED, "TaskLed", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 1, &LedTaskHandle);

	vTaskStartScheduler();

	/* Loop forever */
	while(1);
}
